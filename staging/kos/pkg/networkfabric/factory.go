/*
Copyright 2018 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package networkfabric

import (
	"fmt"
	"strings"
)

// netFabricFactory is the signature of
// the factories of network fabrics.
type netFabricFactory func() Interface

var factoryRegistry map[string]netFabricFactory

// registerFactory registers a netFabricFactory under the given name.
// After a successful invocation, the registered factory can
// be used to get an instance of a network fabric by invoking
// NewNetFabricForName using the same name used for registration
// as the input parameter. This function is meant to be used
// ONLY in init() functions of network fabric implementers.
// Invoking registerFactory more than once with the same name panics.
func registerFactory(name string, factory netFabricFactory) {
	if factoryRegistry == nil {
		factoryRegistry = make(map[string]netFabricFactory, 1)
	}
	if _, nameAlreadyInUse := factoryRegistry[name]; nameAlreadyInUse {
		panic(fmt.Sprintf("a factory with name %s is already registered. Use a different name", name))
	}
	factoryRegistry[name] = factory
}

// NewNetFabricForName returns a network fabric generated by the
// factory registered under the given name. An error is returned if
// no factory is registered under the given name.
func NewNetFabricForName(name string) (Interface, error) {
	newNetFabric, nameIsRegistered := factoryRegistry[name]
	if !nameIsRegistered {
		var err error
		if len(factoryRegistry) > 0 {
			registeredNames := make([]string, 0, len(factoryRegistry))
			for aRegisteredName := range factoryRegistry {
				registeredNames = append(registeredNames, aRegisteredName)
			}
			err = fmt.Errorf("No factory is registered with name %s. Registered names are: %s", name, strings.Join(registeredNames, ","))
		} else {
			err = fmt.Errorf("No factory is regitered with name %s because there are no registered factories", name)
		}
		return nil, err
	}
	return newNetFabric(), nil
}
